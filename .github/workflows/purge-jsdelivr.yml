name: Purge jsDelivr Cache

on:
  push:
    branches:
      - main
    paths:
      - 'cfg/**'
      - 'rule/**'
      - 'game_rule/**'
      - 'shell/**'
      - 'overwrite/**'
      - '!**/archived/**'
      - '!**/README.md'
      - '!README.md'


  workflow_dispatch:  # 支持手动触发

jobs:
  purge-jsdelivr:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    continue-on-error: true
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 

      - name: Soft Debounce (Wait & Check)
        env:
          CURRENT_SHA: ${{ github.sha }}
        run: |
          echo "Current Commit SHA: $CURRENT_SHA"
          echo "Waiting for 60 seconds to batch multiple changes..."
          
          # 倒计时
          for i in {60..1}; do
             # 仅每10秒打印一次日志防止刷屏
             if (( i % 10 == 0 )); then
               echo "$i seconds remaining..."
             fi
             sleep 1
          done
          
          echo "Fetching latest remote info..."
          git fetch origin main
          LATEST_SHA=$(git rev-parse origin/main)
          
          echo "Latest Remote SHA: $LATEST_SHA"
          
          if [ "$CURRENT_SHA" != "$LATEST_SHA" ]; then
            echo "⚠️ A newer commit ($LATEST_SHA) has been detected."
            echo "✅ Skipping this run gracefully to avoid 'Cancelled' notification."
            exit 0
          else
            echo "✅ This is still the latest commit. Proceeding with purge..."
          fi

      - name: Purge jsDelivr Cache
        # 上一步如果 exit 0 了，这里依然会执行吗？
        # exit 0 代表成功，所以这里需要再次判断，或者把 purge 逻辑放在同一个 step 里。
        # 为了逻辑清晰，我们把 purge 整合到上面的脚本里，或者使用 outputs。
        # 最简单的方法：把 purge 逻辑放到同一个 run block 或者使用 if condition based on step outcome.
        # 但 shell exit 0 会结束 step 继续下一个。
        # 我们可以利用一个文件标记。
        run: |
          git fetch origin main
          LATEST_SHA=$(git rev-parse origin/main)
          if [ "${{ github.sha }}" != "$LATEST_SHA" ]; then
            echo "Skipping purge step as newer commit exists."
            exit 0
          fi
          
          REPO="${{ github.repository }}"
          echo "Purging jsDelivr cache for $REPO"

          for i in {1..3}; do
            echo "Attempt $i: Purging..."
            result=$(curl -s -X GET "https://purge.jsdelivr.net/gh/${REPO}")
            echo "$result"

            if echo "$result" | grep -q '"status": "finished"'; then
              echo "Purge succeeded."
              break
            else
              echo "Purge failed, retrying in 5s..."
              sleep 5
            fi

            if [ "$i" -eq 3 ]; then
              echo "Purge failed after 3 attempts."
              exit 1
            fi
          done